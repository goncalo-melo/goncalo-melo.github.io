---
title: "Lost File"
date: 2025-11-07 18:30:00 +0000
categories: [Writeups, Forensics, Securinets CTF 2025]
tags: [forensics, writeup]
---

### Description

My friend told me to run this executable, but it turns out he just wanted to encrypt my precious file.

And to make things worse, I don't even remember what password I used. ðŸ˜“

Good thing I have this memory dump taken at a very convenient moment, right?

### Handout

- disk.ad1
- mem.vmem

### Solve 

```sh
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/lost-file$ file disk.ad1 
disk.ad1: data
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/lost-file$ xxd disk.ad1 | head
00000000: 4144 5345 474d 454e 5445 4446 494c 4500  ADSEGMENTEDFILE.
00000010: 0100 0000 0200 0000 0100 0000 0100 0000  ................
00000020: 0000 8032 0200 0000 0002 0000 0000 0000  ...2............
00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000050: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000060: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000080: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/lost-file$ file mem.vmem 
mem.vmem: data
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/lost-file$ xxd mem.vmem | head
00000000: 53ff 00f0 53ff 00f0 c3e2 00f0 53ff 00f0  S...S.......S...
00000010: 53ff 00f0 54ff 00f0 8884 00f0 53ff 00f0  S...T.......S...
00000020: a5fe 00f0 87e9 00f0 560d 00f0 560d 00f0  ........V...V...
00000030: 560d 00f0 560d 00f0 57ef 00f0 00f5 00f0  V...V...W.......
00000040: 160b 00c0 4df8 00f0 41f8 00f0 3227 4aea  ....M...A...2'J.
00000050: 39e7 00f0 59f8 00f0 ac22 4aea d2ef 00f0  9...Y...."J.....
00000060: 59ff 00f0 f2e6 00f0 6efe 00f0 53ff 00f0  Y.......n...S...
00000070: 53ff 00f0 a4f0 00f0 ed81 00f0 3a13 00c0  S...........:...
00000080: 560d 00f0 560d 00f0 560d 00f0 560d 00f0  V...V...V...V...
00000090: 560d 00f0 560d 00f0 560d 00f0 560d 00f0  V...V...V...V...
```

Files with the .ad1 extension can be analyzed, typically, in a Windows tool called FTK Imager, which allows us to inspect the filesystem of the provided disk image.

We identify the main user, `RagdollFan2005`, and further inspect the common directories.

We notice two important files in the `Desktop` directory: `locker_sim.exe`, likely used to encrypt the "precious" file; and `to_encrypt.txt.enc`, which we can assume is the encrypted version of the "precious" file. We extract both files for further analysis.

`to_encrypt.txt.enc` is indeed an encrypted file:

```sh
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/lost-file$ file to_encrypt.txt.enc 
to_encrypt.txt.enc: data
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/lost-file$ head to_encrypt.txt.enc 
4ï¿½=wJz@/ï¿½#ï¿½uï¿½Gï¿½ï¿½ï¿½2UÉ‰ï¿½xï¿½<ï¿½ï¿½ï¿½Ñ†Cï¿½ï¿½ï¿½Bï¿½ï¿½ï¿½ï¿½qï¿½ï¿½".ï¿½ï¿½aï¿½ï¿½ï¿½ï¿½{x9ï¿½YbGï¿½ï¿½ï¿½ï¿½dï¿½Nï¿½2ï¿½9ï¿½ï¿½oï¿½ï¿½ï¿½Jï¿½$}ï¿½ï¿½ï¿½ï¿½Ð )^ï¿½Dï¿½1ï¿½ï¿½zï¿½ï¿½ï¿½HWï¿½ï¿½hï¿½\ï¿½;ï¿½^ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½&Tï¿½]ï¿½nFï¿½<ï¿½l9ï¿½ï¿½nï¿½6\B
```

The next step is reverse engineering the `locker_sim.exe` file.

```sh
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/lost-file$ file locker_sim.exe 
locker_sim.exe: PE32 executable (console) Intel 80386, for MS Windows
```

The decompiled code produced by Ghidra is as follows:

```c

int __cdecl _main(int _Argc,char **_Argv,char **_Env)

{
  int iVar1;
  DWORD DVar2;
  int iVar3;
  BYTE *pBVar4;
  undefined4 *puVar5;
  CHAR *pCVar6;
  char local_69c [260];
  size_t local_598;
  void *local_594;
  size_t local_590;
  void *local_58c;
  char local_588 [260];
  undefined4 local_484;
  undefined4 local_480;
  undefined4 local_47c;
  undefined4 local_478;
  undefined4 local_474;
  undefined4 local_470;
  undefined4 local_46c;
  undefined4 local_468;
  size_t local_454;
  void *local_450;
  char local_44c [259];
  char cStack_349;
  CHAR local_348 [259];
  char cStack_245;
  undefined4 local_244 [64];
  undefined1 local_141;
  BYTE local_140 [255];
  undefined1 local_41;
  FILE *local_40;
  BYTE *local_3c;
  size_t local_38;
  int local_34;
  DWORD local_30;
  char *local_2c;
  size_t local_28;
  char *local_24;
  int *local_14;
  
  local_14 = &_Argc;
  ___main();
  if (_Argc < 2) {
    return 1;
  }
  local_2c = _Argv[1];
  pBVar4 = local_140;
  for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {
    pBVar4[0] = '\0';
    pBVar4[1] = '\0';
    pBVar4[2] = '\0';
    pBVar4[3] = '\0';
    pBVar4 = pBVar4 + 4;
  }
  iVar3 = read_computername_from_registry(local_140,0x100);
  if (iVar3 != 0) {
    strncpy((char *)local_140,"UNKNOWN_HOST",0xff);
    local_41 = 0;
  }
  fflush((FILE *)(_iob_exref + 0x20));
  puVar5 = local_244;
  for (iVar3 = 0x41; iVar3 != 0; iVar3 = iVar3 + -1) {
    *puVar5 = 0;
    puVar5 = puVar5 + 1;
  }
  pCVar6 = local_348;
  for (iVar3 = 0x41; iVar3 != 0; iVar3 = iVar3 + -1) {
    pCVar6[0] = '\0';
    pCVar6[1] = '\0';
    pCVar6[2] = '\0';
    pCVar6[3] = '\0';
    pCVar6 = pCVar6 + 4;
  }
  local_30 = _GetModuleFileNameA@12((HMODULE)0x0,local_348,0x104);
  if ((local_30 == 0) || (0x103 < local_30)) {
    local_244[0]._0_2_ = 0x2e;
  }
  else {
    for (local_24 = local_348 + (local_30 - 1);
        ((local_348 <= local_24 && (*local_24 != '\\')) && (*local_24 != '/'));
        local_24 = local_24 + -1) {
    }
    if (local_24 < local_348) {
      local_244[0]._0_2_ = 0x2e;
    }
    else {
      local_28 = (int)local_24 - (int)local_348;
      if (local_28 == 0) {
        strncpy((char *)local_244,local_348,0x103);
        local_141 = 0;
      }
      else {
        if (0x103 < local_28) {
          local_28 = 0x103;
        }
        strncpy((char *)local_244,local_348,local_28);
        *(undefined1 *)((int)local_244 + local_28) = 0;
      }
    }
  }
  local_34 = strlen((char *)local_244);
  if ((local_34 == 0) ||
     ((*(char *)((int)local_244 + local_34 + -1) != '\\' &&
      (*(char *)((int)local_244 + local_34 + -1) != '/')))) {
    _snprintf(local_44c,0x104,"%s\\secret_part.txt",local_244);
  }
  else {
    _snprintf(local_44c,0x104,"%ssecret_part.txt",local_244);
  }
  local_450 = (void *)0x0;
  local_454 = 0;
  read_file_to_buffer(local_44c,(int *)&local_450,&local_454);
  _DeleteFileA@4(local_44c);
  iVar3 = strlen(local_2c);
  iVar1 = strlen((char *)local_140);
  local_38 = local_454 + iVar3 + iVar1 + 10;
  local_3c = (BYTE *)malloc(local_38);
  if (local_454 == 0) {
    _snprintf((char *)local_3c,local_38,"%s|%s|",local_2c,local_140);
  }
  else {
    _snprintf((char *)local_3c,local_38,"%s|%s|%s",local_2c,local_140,local_450);
  }
  DVar2 = strlen((char *)local_3c);
  iVar3 = sha256_buf(local_3c,DVar2,(BYTE *)&local_474);
  if (iVar3 == 0) {
    local_484 = local_474;
    local_480 = local_470;
    local_47c = local_46c;
    local_478 = local_468;
    iVar3 = strlen((char *)local_244);
    if ((*(char *)((int)local_244 + iVar3 + -1) == '\\') ||
       (iVar3 = strlen((char *)local_244), *(char *)((int)local_244 + iVar3 + -1) == '/')) {
      _snprintf(local_588,0x104,"%sto_encrypt.txt",local_244);
    }
    else {
      _snprintf(local_588,0x104,"%s\\to_encrypt.txt",local_244);
    }
    local_58c = (void *)0x0;
    local_590 = 0;
    iVar3 = read_file_to_buffer(local_588,(int *)&local_58c,&local_590);
    if (iVar3 == 0) {
      local_594 = (void *)0x0;
      local_598 = 0;
      iVar3 = aes256_encrypt_simple
                        (&local_474,(BYTE *)&local_484,local_58c,local_590,&local_594,&local_598);
      if (iVar3 == 0) {
        iVar3 = strlen((char *)local_244);
        if ((*(char *)((int)local_244 + iVar3 + -1) == '\\') ||
           (iVar3 = strlen((char *)local_244), *(char *)((int)local_244 + iVar3 + -1) == '/')) {
          _snprintf(local_69c,0x104,"%sto_encrypt.txt.enc",local_244);
        }
        else {
          _snprintf(local_69c,0x104,"%s\\to_encrypt.txt.enc",local_244);
        }
        local_40 = (FILE *)fopen(local_69c,"wb");
        if (local_40 == (FILE *)0x0) {
          iVar3 = 1;
        }
        else {
          fwrite(local_594,1,local_598,local_40);
          fclose(local_40);
          if (local_450 != (void *)0x0) {
            free(local_450);
          }
          if (local_58c != (void *)0x0) {
            free(local_58c);
          }
          if (local_594 != (void *)0x0) {
            free(local_594);
          }
          free(local_3c);
          iVar3 = 0;
        }
        return iVar3;
      }
      puts("Encryption failed");
      return 1;
    }
    printf("Target file not found: %s\n");
    return 1;
  }
  puts("SHA256 failed");
  return 1;
}
```

The program builds a secret key from **three** pieces of data, uses that key to AES-256-CBC encrypt a file `to_encrypt.txt`, and writes `to_encrypt.txt.enc` next to the executable. The three inputs used to derive the key are:

1. **argv[1]** (the program argument)
2. the **machine computer name** (read from the registry; if missing it uses "UNKNOWN_HOST")
3. the contents of a local file named **secret_part.txt** (the program reads it and then deletes it)

The argv[1] can be found by analysing the memory dump file, `mem.vmem` with `volatility2` using the `consoles` module.

```sh
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/lost-file$ python2 ~/Desktop/Tools/volatility/vol.py -f mem.vmem imageinfo

INFO    : volatility.debug    : Determining profile based on KDBG search...
          Suggested Profile(s) : WinXPSP2x86, WinXPSP3x86 (Instantiated with WinXPSP2x86)
                     AS Layer1 : IA32PagedMemoryPae (Kernel AS)
                     AS Layer2 : FileAddressSpace (/home/shieda/Desktop/CTFs/securinetsctf2025/lost-file/mem.vmem)
                      PAE type : PAE
                           DTB : 0x341000L
                          KDBG : 0x80545ce0L
          Number of Processors : 1
     Image Type (Service Pack) : 3
                KPCR for CPU 0 : 0xffdff000L
             KUSER_SHARED_DATA : 0xffdf0000L
           Image date and time : 2025-09-30 22:52:53 UTC+0000
     Image local date and time : 2025-09-30 23:52:53 +0100

shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/lost-file$ python2 ~/Desktop/Tools/volatility/vol.py -f mem.vmem --profile WinXPSP2x86 consoles

**************************************************
ConsoleProcess: csrss.exe Pid: 600
Console: 0x4f23b0 CommandHistorySize: 50
HistoryBufferCount: 1 HistoryBufferMax: 4
OriginalTitle: %SystemRoot%\system32\cmd.exe
Title: C:\WINDOWS\system32\cmd.exe
AttachedProcess: cmd.exe Pid: 2284 Handle: 0x458
----
CommandHistory: 0x10386f8 Application: cmd.exe Flags: Allocated, Reset
CommandCount: 2 LastAdded: 1 LastDisplayed: 1
FirstCommand: 0 CommandCountMax: 50
ProcessHandle: 0x458
Cmd #0 at 0x1044400: cd Desktop
Cmd #1 at 0x4f1f90: cls
----
Screen 0x4f2ab0 X:80 Y:300
Dump:
                                                                                
C:\Documents and Settings\RagdollFan2005\Desktop>locker_sim.exe hmmisitreallyts 
**************************************************
ConsoleProcess: csrss.exe Pid: 600
Console: 0x1044560 CommandHistorySize: 50
HistoryBufferCount: 2 HistoryBufferMax: 4
OriginalTitle: ?OystemRoot%\system32\cmd.exe
Title: 
```

We can find the computer name...

Since we know the encryption of the file already happened on the `.ad1` artifact, we conclude that the `secret_part.txt` file has already been deleted. We search the `RECYCLE` directory and find the `Dc1.txt` file which contains the contents of the old `secret_part.txt` file: `sigmadroid`.

> The "Dc" in `Dc*.txt` stands for **Deleted Content** in Windows Recycle Bins. They are usually accompanied by an `INFO` file containing metadata information such as: original file name and path, deletion date/time and file size.
{: .prompt-tip }

So, the **three** components we need to derive the key are `hmmisitreallyts`, `RAGDOLLF-F9AC5A` and `sigmadroid`, resulting in `hmmisitreallyts|RAGDOLLF-F9AC5A|sigmadroid`.

We develop a python script to decrypt the `to_encrypt.txt.enc` file.

```py
from hashlib import sha256
from Crypto.Cipher import AES

INPUT = b'hmmisitreallyts|RAGDOLLF-F9AC5A|sigmadroid'
ENCFILE = 'to_encrypt.txt.enc'
OUTFILE = 'to_encrypt.txt'

d = sha256(INPUT).digest()
key = d
iv  = d[:16]

print("Key (hex):", d.hex())
print("IV  (hex):", iv.hex())

with open(ENCFILE, 'rb') as f:
    ct = f.read()

cipher = AES.new(key, AES.MODE_CBC, iv)
pt = cipher.decrypt(ct)

pad = pt[-1]

open(OUTFILE, 'wb').write(pt)
    
print("Wrote decrypted data to to_encrypt.txt", OUTFILE)
```

After a few chained `base64` encoded strings we finally have our flag.

```sh
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/lost-file$ python3 decrypt.py 
Key (hex): 1117e5b8fdff9d7be375e7a88354c497b93788da64a3968621499687f10474e5
IV  (hex): 1117e5b8fdff9d7be375e7a88354c497
Wrote decrypted data to to_encrypt.txt
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/lost-file$ cat to_encrypt.txt
Vm14U1MxWXlSblJWYkd4VVltdEtjRmxzV2xwa01XdzJWR3BDYkdKSGREWlZNakUwV1ZaYU5sVnViRnBOYWtaWVdXMHhSMWRXVW5GUmJYQnBZbGhTTlZkWGVHdFpWVEZIVVdwYVVGWkhjems9
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/lost-file$ echo "Vm14U1MxWXlSblJWYkd4VVltdEtjRmxzV2xwa01XdzJWR3BDYkdKSGREWlZNakUwV1ZaYU5sVnViRnBOYWtaWVdXMHhSMWRXVW5GUmJYQnBZbGhTTlZkWGVHdFpWVEZIVVdwYVVGWkhjems9" | base64 -d
VmxSS1YyRnRVbGxUYmtKcFlsWlpkMWw2VGpCbGJHdDZVMjE0WVZaNlVubFpNakZYWW0xR1dWUnFRbXBpYlhSNVdXeGtZVTFHUWpaUFZHczk=
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/lost-file$ echo "VmxSS1YyRnRVbGxUYmtKcFlsWlpkMWw2VGpCbGJHdDZVMjE0WVZaNlVubFpNakZYWW0xR1dWUnFRbXBpYlhSNVdXeGtZVTFHUWpaUFZHczk=" | base64 -d
VlRKV2FtUllTbkJpYlZZd1l6TjBlbGt6U214YVZ6UnlZMjFXYm1GWVRqQmpibXR5WWxkYU1GQjZPVGs9
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/lost-file$ echo "VlRKV2FtUllTbkJpYlZZd1l6TjBlbGt6U214YVZ6UnlZMjFXYm1GWVRqQmpibXR5WWxkYU1GQjZPVGs9" | base64 -d
VTJWamRYSnBibVYwYzN0elkzSmxaVzRyY21WbmFYTjBjbmtyYldaMFB6OTk=
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/lost-file$ echo "VTJWamRYSnBibVYwYzN0elkzSmxaVzRyY21WbmFYTjBjbmtyYldaMFB6OTk=" | base64 -d
U2VjdXJpbmV0c3tzY3JlZW4rcmVnaXN0cnkrbWZ0Pz99
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/lost-file$ echo "U2VjdXJpbmV0c3tzY3JlZW4rcmVnaXN0cnkrbWZ0Pz99" | base64 -d

Securinets{screen+registry+mft??}
```

